# Реализация приоритетной очереди на основе бинарной кучи, упорядоченной таблицы и бинарного поискового дерева и её применение для построения остовного дерева графа с помощью алгоритма Краскала

## Содержание

* [Постановка задачи](#Постановка-задачи)
* [Руководство пользователя](#Руководство-пользователя)
	* [Использование реализации пирамидальной сортировки](#Использование-реализации-пирамидальной-сортировки)
    * [Использование реализации алгоритма Дейкстры](#Использование-реализации-алгоритма-Дейкстры)
	* [Использование реализации алгоритма Краскала](#Использование-реализации-алгоритма-Краскала)
* [Руководство программиста](#Руководство-программиста)
	* [Используемые технологии](#Используемые-технологии)
	* [Общая структура репозитория](#Общая-структура-репозитория)
	* [Описание структуры решения](#Описание-структуры-решения)
	* [Описание структур данных](#Описание-структур-данных)
		* [Бинарная куча](#бинарная-куча)
		* [Бинарное поисковое дерево](#Бинарное-поисковое-дерево)
		* [Таблицы](#Таблицы)
			* [Просматриваемые таблицы](#Просматриваемые-таблицы)
			* [Упорядоченные таблицы](#Упорядоченные-таблицы)
		* [Приоритетные очереди](#Приоритетные-очереди)
      * [Разделенные множества](#Разделенные-множества)
	* [Описание алгоритмов](#Описание-алгоритмов)
		* [Пирамидальная сортировка](#Пирамидальная-сортировка)
		* [Алгоритм Дейкстры](#Алгоритм-Дейкстры)
		* [Алгоритм Краскала](#Алгоритм-Краскала)
	* [Программная реализация структур данных](#Программная-реализация-структур-данных)
		* [Программная реализация бинарной кучи](#Программная-реализация-бинарной-кучи)
		* [Программная реализация бинарного поискового дерева](#Программная-реализация-бинарного-поискового-дерева)
		* [Программная реализация просматриваемых таблиц](#Программная-реализация-просматриваемых-таблиц)
		* [Программная реализация упорядоченных таблиц](#Программная-реализация-упорядоченных-таблиц)
		* [Программная реализация приоритетной очереди на основе D-кучи](#Программная-реализация-приоритетной-очереди-на-основе-d-кучи)
		* [Программная реализация приоритетной очереди на основе бинарного поискового дерева](#Программная-реализация-приоритетной-очереди-на-основе-бинарного-поискового-дерева)
		* [Программная реализация приоритетной очереди на основе упорядоченной таблицы](#Программная-реализация-приоритетной-очереди-на-основе-упорядоченной-таблицы)
		* [Программная реализация разделенных множеств](#Программная-реализация-разделенных-множеств)
		* [Программная реализация графа](#Программная-реализация-графа)
* [Заключение](#Заключение)
* [Литература](#Литература)


##Постановка задачи

1. Разработать статические библиотеки, реализующие следующие структуры данных:
	- бинарную кучу;
	- бинарное поисковое дерево;
	- граф;
	- разделенные множества;
	- таблицу;
	- просматриваемую таблицу;
	- упорядоченную таблицу;
	- приоритетную очередь, основанную на бинарной куче;
	- приоритетную очередь, основанную на бинарном поисковом дереве;
	- приоритетную очередь, основанную на упорядоченной таблице.
2. Разработать тестирующую программу для каждого метода каждой структуры данных с помощью Google C++ Testing Framework.
3. Разработать приложение для демонстрации работы бинарной кучи (пирамидальная сортировка).
4. Разработать приложение для демонстрации работы приоритетной очереди, основанной на бинарной куче (алгоритм Дейкстры):
	- входные данные - связный неориентированный взвешенный граф без петель со стартовой вершиной;
	- выходные данные:
	    - список вершин;
	    - список кратчайших путей до каждой вершины графа;
	    - список предшествующий вершин.
5. Разработать приложение для демонстрации работы приоритетных очередей (на базе бинарной кучи, бинарного поискового дерева и упорядоченной таблицы) и разделенных множеств (алгоритм Краскала):
	* входные данные - связный неориентированный взвешенный граф без петель;
	* выходные данные - граф, представляющий минимальное остовное дерево для введённого графа.

##Руководство пользователя

###Использование реализации пирамидальной сортировки

####Запуск приложения и ввод данных

Программа предназначена для сортировки D-кучи.
Для запуска приложения нужно открыть исполняемый файл `sample-sort.exe`.
В программу необходимо ввести размерность кучи и количество элементов в ней. Программа автоматически заполнит дерево, с учетом Ваших данных, и на экран выведется сначала исходная куча, затем отсортированная.

####Пример:

1) После запуска программы необходимо ввести размерность кучи:

![1](/img/d1.png)

2) Следующим шагом необходимо ввести размер кучи:

![2](/img/d2.png)

3) После этого программа выведет исходную и отсортированную кучу:

![3](/img/d3.png)

###Использование реализации алгоритма Дейкстры

####Запуск приложения и ввод данных

Программа предназначена для поиска кратчийших путей во взвешенном неориентированном графе от любой вершины до всех остальных вершин графа.
Для запуска приложения нужно открыть исполняемый файл `sample-Dijkstra.exe`.
Программа попросит ввести количество вершин графа и количество ребер. На выбор есть два варианта ввода рёбер графа: случайным образом и вручную. Если Вы выбрали ввод случайным образом,необходимо ввести минимальное и максимальное значения весов ребер. В ручном режиме необходимо ввести рёбра в формате (начальная вершина, конечная вершина, вес). Также будет запрошен номер стартовой вершины. Результатом будет вывод номеров всех вершин, кратчайших путей от стартовой вершины и номеров предшествующих вершин.


####Пример (ввод графа вручную):

1) Необходимо ввести количество вершин графа:

![4](/img/s1.png)

2) Затем необходимо ввести количество ребер графа:

![5](/img/s2.png)

3) Теперь выберите способ задания графа(выберите ввести граф вручную):

![6](/img/s3.png)

4) Введите рёбра в формате (начальная вершина, конечная вершина, вес):

![7](/img/s4.png)

5) Введите точку входа в граф и наблюдайте результат:



###Использование реализации алгоритма Краскала

####Запуск приложения и ввод данных

Программа предназначена для построения минимального остовного дерева для взвешенного неориентированного графа. 
Для запуска приложения нужно открыть исполняемый файл `sample-Kruskal.exe`.
Необходимо выбрать тип структуры данных, на которой будет основываться приоритетная очередь, и количество вершин графа. Затем выбрать, каким образом заполнять граф: случайным образом или вручную. Результатом работы программы будет вывод списка ребер, составляющих минимальное остовное дерево, и их весов.

####Пример

1) Выберите структуру данных для приоритетной очереди:

![8](/img/k1.png)

2) Вводим количество вершин и количество рёбер графа:

![9](/img/k3.png)

3) Выбираем способ заполнения графа (в данном случае случайный ввод):

![10](/img/k4.png)

Если выбрать автоматическое заполнение графа, программа запросит минимальное и максимальное значение графа.

4)Вводим необходимые данные:

![11](/img/k5.png)

5) Программа завершила работу и вывела результат на экран:

![12](/img/k6.png)


##Руководство программиста

###Используемые технологии

В ходе выполнения работы использовано следующее ПО:
- Среда разработки Microsoft Visual Studio 2015.
- Фреймворк для написания автоматических тестов Google Test.
- Система контроля версий Git.

###Общая структура репозитория

Репозиторий содержит следующие директории и файлы:

* [`gtest`](https://github.com/mkildishev/mp2-lab4-graph/tree/master/gtest) - библиотека GoogleTest.
* [`include`](https://github.com/mkildishev/mp2-lab4-graph/tree/master/include) - каталог для размещения заголовочных файлов и реализаций структур данных.
* [`sample_Dijkstra`](https://github.com/mkildishev/mp2-lab4-graph/tree/master/sample-Dijkstra) - каталог для размещения исходного кода приложения алгоритма Дейкстры.
* [`sample_Kruskal`](https://github.com/mkildishev/mp2-lab4-graph/tree/master/sample-Kruskal) - каталог для размещения исходного кода приложения алгоритма Краскала.
* [`sample_sort`](https://github.com/mkildishev/mp2-lab4-graph/tree/master/sample-sort) - каталог для размещения исходного кода приложения пирамидальной сортировки.
* [`test`](https://github.com/mkildishev/mp2-lab4-graph/tree/master/test) - каталог для размещения тестов.
* [`sln`](https://github.com/mkildishev/mp2-lab4-graph/tree/master/sln/vc14) - каталог с файлими решений.
* [`img`](https://github.com/mkildishev/mp2-lab4-graph/tree/master/img) - каталог с изображениями для отчета;
* [`src`](https://github.com/mkildishev/mp2-lab4-graph/tree/master/src) - каталог для размещения реализационных файлов

###Описание структуры решения

Решение состоит из 12 проектов:

* `Binary tree` - статическая библиотка, содержащая объявление и реализацию шаблонного класса `Binary_search_tree`.
* `D_heap` - статическая библиотека, содержащая объявление и реализацию шаблонного класса `D_heap`.
* `Graph` - статическая библиотека, содержащая объявление и реализацию шаблонного классов `Graph`.
* `gtest` - фреймворк Google Test.
* `Disjoint_set` - статическая библиотека, содержащая объявление и реализацию шаблонного класса разделенных множестве `Disjoint_set`.
* `Algorithm` - статическая библиотека, содержащая объявление и реализацию шаблонных классов алгоритма Краскала `Kruskal` и Дейкстры `Dijkstra`.
* `Priority Queue` - статическая библиотека, содержащая объявление и реализацию виртуального шаблонного класса приоритетной очереди и шаблонных классов-наследников приоритетных очередей, основанных на д-куче, бинарном поисковом дереве и упорядоченной таблице `Priority_queue`, `Queue_on_heap`, `Queue_on_tree`, `Queue_on_table`.
* `sample-Dijkstra` - консольное приложение для демонстрации работы алгоритма Дейкстры.
* `sample-Kruskal` - консольное приложение для демонстрации работы алгоритма Краскала.
* `sample-sort` - консольное приложение для демонстрации работы пирамидальной сортировки.
* `Table` - статическая библиотека, содержащая объявление и реализацию шаблонных классов `TabRecord`, `Table`, `ScanTable`, `SortTable`.
* `test` - консольное приложение для проверки правильности реализации классов `Binary_search_tree`, `D_heap`, `Graph`, `Queue_on_heap`, `Queue_on_tree`, `Queue_on_table`, `Disjoint_set`, `Scan_table`, `Sort_table`.


###Описание структур данных

####D-куча
D-куча - завершенное d-арное дерево, содержащее набор однотипных элементов, со следующими свойствами:
- каждый узел, не являющийся листом, за исключением, быть может, одного имеет ровно d потомков. Один узел, являющийся исключением, может иметь от 1 до d-1 потомка;
- если h - глубина дерева, то для любого i = 1, ..., k-1 такое дерево имеет ровно d^i узлов глубины i;
- количество узлов глубины k в дереве глубины k может варьироваться от 1 до d^k;
- каждый узел имеет вес. Иначе говоря, каждому узлу дерева присвоен ключ такого типа данных, на котором определен порядок сравнения;
- ключ элемента, приписанного узлу i, не превосходит ключа любого из своих потомков.


####Бинарное дерево

#####Бинарное поисковое дерево
Бинарное поисковое дерево - это двоичное дерево, обладающее следующими свойствами:
* каждый узел имеет не больше двух потомков;
* любое поддерево является бинарным поисковым деревом;
* значение ключа любого узла левого поддерева меньше значения ключа корневого узла;
* значение ключа любого узла правого поддерева больше значения ключа корневого узла.
```


####Таблицы

#####Просматриваемые таблицы
Таблица - динамическая структура данных, хранящая однотипные элементы. Записи хранятся в векторе памяти в порядке добавления (добавление производится в конец таблицы). При удалении записи просиходит перепаковка (сдвиг всех записей ниже текущей на одну позицию вверх).
```

#####Упорядоченные таблицы
Упорядоченная таблица - это просматриваемая таблица, данные в которой отсортированы по невозрастанию/неубыванию ключей. Причем при вставке и удалении происходят перепаковки.
```

####Приоритетные очереди
Приоритетная очередь — это динамическая структура данных, содержащая элементы, каждый из которых имеет определенный приоритет. Элемент с более высоким приоритетом находится перед элементом с более низким приоритетом. Если у элементов одинаковые приоритеты, они располагаются в зависимости от своей позиции в очереди. 
```
######Основные операции:
* Вставка элемента `Push`.
* Удаление элемента с максимальным приоритетом `Pop`.
* Получение элемента с максимальным приоритетом `Top`.
* Проверка очереди на пустоту `IsEmpty`.
* Проверка очереди на полносту `IsFull`.
```
####Разделенные множества
Разледенные множества - абстрактный тип данных, предназначенный для представления коллекции k попарно непересекающихся можеств.
```

###Описание алгоритмов

####Пирамидальная сортировка
1. На вход поступает 2 значения: размерность кучи и количество элементов.
2. Формируется куча с данными условиями.
3. Просматривается минимальный элемент кучи и кладется в результирующую кучу.
4. Минимальный элемент D-кучи меняется с последним.
5. Размер D-кучи уменьшаем на 1.
6. Погружаем нулевой элемент.
7. Если размер кучи положителен, переход к п.3, иначе алгоритм завершается.

Таким образом, возвращаемые значения будут отсортированы по возрастанию.

####Алгоритм Дейкстры

1. На вход поступает количество вершин, рёбер, минимальное и максимальное значение веса ребра.
2. Исходя из заданных условий формируется граф `graph`.
3. Задается стартовая вершина `s`.
4. Создается массив для отметки посещения вершины `vis`. Всем элементам (кроме `vis[s] = s`) присваивается -1.
5. Создается результирующий массив расстояний `dist` (все элементы равны `MAX`, `dist[s] = 0`).
6. Создается приоритетная очередь, в которую кладется расстояние от текущей вершины до неё же.
7. Вынимается минимальный элемент.
8. Если метка вынутого элемента больше метки, хранящейся в массиве `dist`, переходим к следующему шагу.
9. Проходим по всем ребрам от текущей вершины. Если результирующее расстояние от смежной вершины больше, чем результирующее расстояние до вынутой в пункте 7 вершины в сумме с меткой ребра, вынутого в пункте 9, то:
		- В `vis`  по номеру смежной вершины кладется значение вершины, вынутой на этапе 7.
		- В `dist` по номету смежной вершины пишется новое значение расстояния, равное сумме результирующего расстояния до вынутой в пункте 7 вершины и меткои ребра, вынутогов пункте 9.
		- Обработанное ребро кладется в очередь.
10. Выполняем пункты 7-9 до тех пор, пока очередь не опустеет.
11. На выходе получим 2 массива: 
    - Массив `dist` содержит кратчайшие расстояния до каждой вершины графа `graph`.
    - Массив `vis` содержит предшествующие вершины.

####Алгоритм Краскала

1. На вход поступает количество вершин `n`, рёбер, минимальное и максимальное значение веса ребра(если автоматическое заполнение).
2. Исходя из заданных условий формируется граф `graph`.
3. Создается приоритетная очередь из ребер графа `queue` (приоритет по весу ребра).
4. Создается разделенное множество из всех вершин `set`.
5. Вынимается ребро из приоритетной очереди.
6. Если вершины, вынутые из очереди не принадлежат одному множеству, то 2 множества (под номерами вершин) объдиняются, а данное ребро добавляется в результирующий граф `tree`.
7. Если количество вершин `tree` не превышает количество `n-1` и если очередь не пуста, то переходим к п.5, иначе алгоритм завершается.

В результате работы алгоритма имеется набор ребер и их весов, составляющих минимальное остовное дерево для данного графа.

###Программная реализация структур данных

####Схема наследования классов
![13](/img/Безымянный.png)

####Программная реализация d-кучи
В работе D-куча представлена классом `D_heap`, содержащим следующие поля:
- `int d` - арность дерева.
- `KeyType *keys` - массив ключей.
- `int count` - количество элементов.

Класс содержит следующие методы:
- `GetParent(int)` -  возвращает индекс родителя.
- `Swap(const int, const int)` - транспонирование 2-х елементов.
- `SiftUp(int)` - операция всплытия.
- `SiftDown(int)` - операция погружения.
- `MinChild(int)` - минимальный "ребенок".
- `RemoveMin()` - операция удаления минимального элемента.
- `Remove(int)` - операция удаления элемента с заданным индексом.
- `Push(KeyType)` - вставка элемента.
- `Heapify()` - операция окучивания.
- `Print()` - вывод кучи на экран.
- `operator==(const D_heap<KeyType>&)const` - проверка на равенство.
- `operator=(const _heap<KeyType>&)` - перегрузка оператора `=`.
- `GetCount()` - возвращает количество элементов в куче.
- `GetKey(KeyType)` - возвращает ключ заданного элемента.

####Программная реализация бинарного поискового дерева
Узел дерева представляется классом `Node`, содержащим следующие поля:
* `KeyType data` - данные.
* `Node<KeyType>* left` - указатель на левого потомка.
* `Node<KeyType>* right` - указатель на правого потомка.
* `Node<KeyType>* parent` - укаазатель на родителя.
* `int balance` - баланс поддерева.

Бинарное поисковое дерево представлено классом `Binary_search_tree`, содержащим следующие поля:
* `int size` - размер дерева.
* `Node<KeyType> *root` - указатель на корень дерева.

Класс содержит следующие методы:
* `Copy(Node<KeyType> *)` - копирование дерева.
* `Push(Node<KeyType>*&, const Node<KeyType> *)` - вставка элемента.
* `Remove(Node<KeyType>*&, const KeyType &)` - удаление элемента.
* `FindKey(Node<KeyType>*, const KeyType &)` - поиск элемента по ключу.
* `FindMax(Node<KeyType>*)` - поиск максимального элемента.
* `FindMin(Node<KeyType>*)` - поиск минимального элемента.
* `FindNext(Node<KeyType>*, Node<KeyType>*)` - поиск элемента, следующего за заданным.
* `FindPrevious(Node<KeyType>*, Node<KeyType>*)` - поиск элемента, предшествующего заданному.
* `WorkAroundWidth(Node<KeyType>*)` - обход в ширину.
* `WorkAroundForward(Node<KeyType>*)` - прямой обход.
* `WorkAroundReverse(Node<KeyType>*)` - обратный обход.
* `WorkAroundSymmetric(Node<KeyType>*)` - симметричный обход.
* `WorkAroundDepth(Node<KeyType>*)` - обход в глубину.
* `operator==(const bintree<KeyType>&)const` - проверка на равенство.
* `GetSize()` - возвращает количество элементов.
* `GetHeight(Node<KeyType>*)` - высота поддерева

####Программная реализация просматриваемых таблиц
Запись в таблице представлена классом `TabRecord`, содержащим следующие поля:
* `int key` - ключ.
* `KeyType data` - данные.

База для всех таблиц представлена классом `Table`, имеющим следующие поля:
* `int size` - размер таблицы.
* `int count` - количество записей в таблице.
* `int pos` - текущая позиция.

Класс содержит чисто виртуальные методы:
* `FindKey(int)` - поиск элемента по идентификатору.
* `Push(int, KeyType)` - вставка элемента.
* `Remove(int)` - удаление элемента
* `IsEmpty()` - проверка на пустоту.
* `IsFull()` - проверка на полноту.
* `GetCount()` - возвращает текущее количество записей.
* `Reset()` - сбрасывает указатель на `0`.
* `GoNext()` - переход к следующей записи.
* `IsTabEnded ()` - возвращает `1`, если таблица закончилась, и `0`, если нет.

Просматриваемые таблицы представлены классом `Scan_table`, содержащим поле:
* `TabRecord<KeyType>** recs` - записи в таблице.

Класс содержит следующие методы:
* `FindKey(int)` - поиск элемента.
* `Push(int, KeyType)` - вставка элемента.
* `Remove(int)` - удаление элемента.
* `Print()` - вывод таблицы на экран.

####Программная реализация упорядоченных таблиц
Упорядоченные таблицы наследуются от класса `Scan_table` и представлены классом `Sort_table`, содержащим следующие методы:
* `Sort()` - сортировка данных.
* `FindKey(int)` - поиск элемента.
* `Push(int, KeyType)` - вставка элемента.
* `Remove(int)` - удаление элемента.
* `Min()` - возвращает минимальный элемент.


####Программная реализация приоритетной очереди на основе D-кучи
Приоритетная очередь на основе D-кучи представлена классом `Queue_on_heap`, содержащим поле:
* `D_heap<KeyType> *heap` - указатель на кучу.

Класс содержит следующие методы:
* `Push(const KeyType)` - вставка элемента.
* `Pop()` - удаление элемента с максимальным приоритетом.
* `IsEmpty()` - проверка на пустоту.
* `IsFull()` - проверка на полноту.
* `Top()` - возвращает элемент с максимальным приоритетом.
* `Print()` - вывод очереди на экран.
* `GetSize ()` - возвращает количество элементов в очереди.
* `operator==(const Queue_on_heap<KeyType>&)const` - проверка на равенство.

####Программная реализация приоритетной очереди на основе бинарного поискового дерева
Приоритетная очередь на основе бинарного поискового дерева представлена классом `Queue_on_tree`, содержащим поле:
* `Binary_search_tree<KeyType> *tree` - указатель на дерево.

Класс содержит следующие методы:
* `Push(const KeyType)` - вставка элемента.
* `Pop()` - удаление элемента с максимальным приоритетом.
* `IsEmpty()` - проверка на пустоту.
* `IsFull()` - проверка на полноту.
* `Top()` - возвращает элемент с максимальным приоритетом.
* `Print()` - вывод очереди на экран.
* `GetSize ()` - возвращает количество элементов в очереди.
* `operator==(const Queue_on_tree<KeyType>&)const` - проверка на равенство.

####Программная реализация приоритетной очереди на основе упорядоченной таблицы
Приоритетная очередь на основе упорядоченной таблицы представлена классом `Queue_on_table`, содержащим поля:
* `Sort_table<KeyType>* table` - указатель на таблицу.
* `int s` - размер.

Класс содержит следующие методы:
* `Push(int, KeyType);` - вставка элемента.
* `Pop()` - удаление элемента с максимальным приоритетом.
* `IsEmpty()` - проверка на пустоту.
* `IsFull()` - проверка на полноту.
* `Top()` - возвращает элемент с максимальным приоритетом.
* `Print()` - вывод очереди на экран.
* `GetSize ()` - возвращает количество элементов в очереди.

####Программная реализация разделенных множеств
Разделенные множества представлены классом `Disjoint_set`, содержащим следующие поля:
* `int *parent` - указатель на родителя.
* `int *height` - высота.
* `int n` - размер.

Класс содержит следующие методы:
* `CreateSet(int)` - создает одноэлементное множество.
* `FindSet(int)` - возвращает главный элемент множества
* `UnionSet(int, int)` - объединяет множества.
* `Print()` - выводит множества на экран.
* `GetSet(int)` - возвращает массив, в котором: первый-элемент - количество элементов в данном множестве, последующие элементы - данное множество.

####Программная реализация графа
Каждое ребро графа представлены классом `Edge`, содержащим:
* `int from` - стартовая вершина
* `int to` - конечная вершина
* `KeyType weight` - вес ребра

Граф представлен классом `Graph`, содержащим следующие поля:
* `int n` - количество вершина графа.
* `int m` - количество ребер графа.
* `Edge<KeyType>** edges` - массив ребер.
* `int current` - текущее ребро.

Класс содержит следующие методы:
* `CreateGraph(KeyType, KeyType)` - создает граф (на вход принимается минимальное и максимальное значение веса ребра).
* `Push(int, int, KeyType)` - добавляет ребро с заданными условиями (откуда, куда, вес).
* `Remove(int, int)` - удаляет заданное ребро
* `GetCount()` - возвращает количество вершин
* `GetEdgeSize()` - возвращает максимальное количество рёбер.
* `GetRealSize()` - возвращает реальное количество рёбер.
* `GetEdge(int)` - возвращает ребро.
* `GetWeight(int, int)` - возвращает вес ребра
* `Print()` - вывод граф на экран

##Заключение
В ходе лабораторной работы:
* Были реализованы структуры данных:
 - "D-куча"
 - "Бинарное поисковое дерево"
 - "Таблица"
 - "Просматриваемая таблица"
 - "Упорядоченная таблица"
 - "Приоритетная очередь на основе D-кучи"
 - "Приоритетная очередь на основе бинарного поискового дерева"
 - "Приоритетная очередь на основе упорядоченой таблицы"
 - "Графы"
 - "Разделенные множества"
с использованием шаблонных классов. 
* Написано тестирующее приложение, которое покрывает все методы, используемые в указанных классах. Все тесты успешно пройдены. 
* Написаны консольные приложения:
 - Пирамидальная сортировка массива.
 - алгоритм Дейкстры для поиска кратчайших путей от любой стартовой вершины связного неориентированного взвешенного графа без петель, реализованного на основе приоритетной очереди на базe D-кучи.
 - алгоритм Краскала для построения минимального остовного дерева неориентированного взвешенного графа без петель, реализованного на основе приоритетных очередях на базе D-кучи, бинарного поискового дерева и упорядоченной таблицы.

##Литература
1. Кормен Т., Лейзерсон Ч., Риверст Р., Штайн К. Алгоритмы. Построение и анализ. - М.: Издательский дом "Вильямс". - 2005. - 1290с.
2. Алексеев В.Е., Таланов В.А. Графы. Модели вычислений. Структуры данных: Учебник. – Нижний Новгород: Изд-во ННГУ, 2005. 307 с.


